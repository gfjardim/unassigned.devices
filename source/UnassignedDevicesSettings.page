Menu="Utilities"
Title="Unassigned Devices"
Icon="unlock-alt"
---
<?php
/* Copyright 2015, Guilherme Jardim
 * Copyright 2016-2020, Dan Landon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

$plugin = "unassigned.devices";
$docroot = $docroot ?? $_SERVER['DOCUMENT_ROOT'] ?: '/usr/local/emhttp';
$translations = file_exists("$docroot/webGui/include/Translations.php");
require_once "$docroot/plugins/$plugin/include/Legacy.php";
?>
<?if (! $translations):?>
<?eval('?>'.parse_file("$docroot/plugins/$plugin/UnassignedDevicesSettings.page"))?>
<?else:?>
<?
require_once "plugins/$plugin/include/lib.php";

$config_file = "/tmp/$plugin/config/$plugin.cfg";
$cfg = is_file($config_file) ? @parse_ini_file($config_file, true) : array();

$uuid_devices = array();
$encrypt_devices = array();
foreach (get_all_disks_info() as $d) {
	if (($d['partitions'][0]['fstype'] == "xfs") && (! $d['partitions'][0]['mounted'])) {
		$a = array();
		$a['device'] = $d['device'];
		$a['label'] = $d['serial'];
		$uuid_devices[] = $a;
	}
	if ($d['partitions'][0]['fstype'] == "crypto_LUKS") {
		$a = array();
		$a['label'] = $d['serial'];
		$encrypt_devices[] = $a;
	}
}

if (count($_POST)) {
	if ($_POST['#apply'] == "_(Apply)_") {
		array_map(function($k, $v) use (&$cfg) { if($k[0] != "#") $cfg["Config"][$k] = $v; }, array_keys($_POST), $_POST );
		unassigned_log("Updating share settings...");
		remove_shares();
		save_ini_file($config_file, $cfg);
		reload_shares();
		unassigned_log("Share settings updated.");
	} else if (($_POST['#command'] == "UUID") && (isset($_POST['change_uuid']))) {
		$dev = substr($_POST['change_uuid'], 1, 8)."1";
		change_UUID($dev);
	} else if ($_POST['#command'] == "chg_pass") {
		$serial = $_POST['set_pass'];
		$password = $_POST['password'];
		set_config($serial, "pass", encrypt_data($password));
	}
}

$use_netbios = ($var['USE_NETBIOS'] == 'yes') ? TRUE : FALSE;
$parted = file_exists("/usr/sbin/parted");

if ((! $use_netbios && $cfg['Config']['samba_v1'] == "yes") || (! file_exists("/usr/sbin/parted") && $cfg['Config']['destructive_mode'] == "enabled")) {
	if (! $use_netbios) {
		$cfg['Config']['samba_v1'] = "no";
	}
	if (! $parted) {
		$cfg['Config']['destructive_mode'] = "disabled";
	}
	save_ini_file($config_file, $cfg);
}
?>

<script type="text/javascript" src="<?autov('/webGui/javascript/jquery.filetree.js')?>"></script>
<link type="text/css" rel="stylesheet" href="<?autov('/webGui/styles/jquery.filetree.css')?>" >

<style type="text/css">
	.fileTree {
		border: solid 1px #BBB;
		background: #FFF;
		overflow: scroll;
		padding: 5px;
		position:absolute;
		z-index:100;
		display:none;
		color:initial;
	}
</style>

<script type="text/javascript">
	function openFileBrowser(el, root, filter, on_folders, on_files, close_on_select) {
		if (on_folders === undefined) on_folders = true;
		if (on_files   === undefined) on_files = true;
		if (! filter && ! on_files)   filter = 'HIDE_FILES_FILTER';
		if (! root.trim() ) root = '/mnt/user/';
		var p = $(el);
		/* Skip if fileTree is already open */
		if ( p.next().hasClass('fileTree') ){return null;}
		/* create a random id */
		var r = Math.floor((Math.random()*1000)+1);
		/* Add a new span and load fileTree */
		p.after("<span id='fileTree"+r+"' class='textarea fileTree'></span>");
		var ft = $('#fileTree'+r);
		ft.fileTree({
			root: root,
			filter: filter,
			allowBrowsing : true
			},
			function(file){if(on_files){p.val(file);if(close_on_select){ft.slideUp('fast',function (){ft.remove();});}};p.trigger('change');},
			function(folder){if(on_folders){p.val(folder);if(close_on_select){$(ft).slideUp('fast',function (){$(ft).remove();});}};p.trigger('change');}
		);
		/* Format fileTree according to parent position, height and width */
		ft.css({'left':p.position().left,'top':( p.position().top + p.outerHeight() ),'width':(p.width()) });
		/* close if click elsewhere */
		$(document).mouseup(function(e){if (! ft.is(e.target) && ft.has(e.target).length === 0){ft.slideUp('fast',function (){$(ft).remove();});}});
		/* close if parent changed */
		p.bind('keydown',function(){ft.slideUp('fast',function (){$(ft).remove();});});
		/* Open fileTree */
		ft.slideDown('fast');
	} 

	function prepareSecurity(el) {
		$("#smb_security").css("display", ( $(el).val() == "no" ? "none" : "block") );
	}
</script>

<div id="title" class="nocontrol">_(Common Settings)_</div>
<form markdown="1" name="common_settings" method="POST">

<?if (! $parted):?>
:ud_settings_plus_plug:
> **Note:** The 'Unassigned Devices Plus' plugin must be installed in order to mount HFS+ and exFAT disk formats, and enable desctrctive mode.
:end
<?endif;?>

_(Common Script)_:
: <input type="text" name="common_cmd" onclick="openFileBrowser(this,'/boot/config/plugins/<?=$plugin;?>/','sh',false,true,true);" value="<?=$cfg['Config']['common_cmd'];?>">

:ud_settings_common_script_plug:
> If set, this script will run before the device script.  The action is in the environment variable **$ACTION**. Be sure you reference all commands with their full path.
:end

_(Destructive Mode)_:
: <select name="destructive_mode" size="1" <?if (! $parted):?>disabled<?endif;?>>
  <?=mk_option($cfg["Config"]["destructive_mode"], "disabled", "_(Disabled)_");?>
  <?=mk_option($cfg["Config"]["destructive_mode"], "enabled", "_(Enabled)_");?>
  </select><?if (! $parted):?>&nbsp;_(The 'Unassigned Devices Plus' plugin must be installed to enable Destructive Mode)_.<?endif;?>

:ud_settings_destructive_plug:
> If enabled, this will allow you to erase and format partitions using Unassigned Devices. This cannot be enabled unless the 'Unassigned Devices Plus' plugin is installed.
:end

_(Auto Mount USB Devices)_?
: <select name="automount_usb" size="1">
  <?=mk_option($cfg["Config"]["automount_usb"], "no", "_(No)_");?>
  <?=mk_option($cfg["Config"]["automount_usb"], "yes", "_(Yes)_");?>
  </select>

:ud_settings_mount_usb_devices_plug:
> When set to **Yes**, will auto mount a new USB device and share it without user intervention.
:end

_(Mount SSDs with 'discard' option)_?
: <select name="discard" size="1">
  <?=mk_option($cfg["Config"]["discard"], "yes", "_(Yes)_");?>
  <?=mk_option($cfg["Config"]["discard"], "no", "_(No)_");?>
  </select>

:ud_settings_discard_plug:
> Mount SSDs that support discard with 'discard' option.  If you are using the SSD Trim Settings to do a periodic trim of SSDs you can set this to **No**.
:end

_(Spin down disks)_?
: <select name="spin_down" size="1">
  <?=mk_option($cfg["Config"]["spin_down"], "yes", "_(Yes)_");?>
  <?=mk_option($cfg["Config"]["spin_down"], "no", "_(No)_");?>
  </select>

:ud_settings_spin_down_plug:
> Set to **Yes** to set a 15 minute disk spin down timer.  Set to **No** to keep disks spun up.
:end

_(Force all SMB remote shares to SMB v1)_?
: <select name="samba_v1" size="1" <?if (! $use_netbios):?>disabled<?endif;?>>
  <?=mk_option($cfg["Config"]["samba_v1"], "no", "_(No)_");?>
  <?=mk_option($cfg["Config"]["samba_v1"], "yes", "_(Yes)_");?>
  </select><?if (! $use_netbios):?>&nbsp;<span style="font-weight: bold">NetBIOS</span> _(must be enabled in SMB Settings to enable SMB v1)_.<?endif;?>

:ud_settings_force_smb_plug:
> Normally a SMB remote share will be mounted with the highest version of SMB that the remote server will support.  When set to **Yes**, all SMB remote shares will be forced to mount with SMB v1.  Some remote shares will give errors when mounted with SMB v2.  SMB v1 has security issues and should not be used unless absolutely necessary.  This cannot be enabled if NetBIOS is disabled.
:end

&nbsp;
: <input type="submit" name="#apply" value='_(Apply)_'><input type="button" value='_(Done)_' onclick="done()">
</form>

<div id="title" class="nocontrol">_(SMB Security)_</div>
<form markdown="1" name="smb_settings" method="POST">
_(Enable SMB Security)_?
: <select name="smb_security" size="1" onchange="prepareSecurity(this);">
  <?=mk_option($cfg['Config']["smb_security"], "no", "_(No)_");?>
  <?=mk_option($cfg['Config']["smb_security"], "yes", "_(Yes)_");?>
  <?=mk_option($cfg['Config']["smb_security"], "hidden", "_(Yes (hidden))_");?>
  </select>

<div id="smb_security" style="display: <?=($cfg['Config']["smb_security"] == "no" || $cfg['Config']["smb_security"] == "" ? "none" : "block");?>">
	<?php foreach ($users as $user): ?>
	<?php if ($user['name'] == "root"): continue; endif;?>
	<dl>
		<dt><?=$user['name'];?></dt>
		<dd>
			<select name="smb_<?=$user['name'];?>" size="1">
			<?=mk_option($cfg["Config"]["smb_{$user[name]}"], "no-access", "_(No Access)_");?>
			<?=mk_option($cfg["Config"]["smb_{$user[name]}"], "read-write", "_(Read/Write)_");?>
			<?=mk_option($cfg["Config"]["smb_{$user[name]}"], "read-only", "_(Read-only)_");?>
			</select>
		</dd>
	</dl>
	<?php endforeach; ?>
</div>

:ud_settings_smb_security_plug:
> Set the user level of SMB Security.
>
> + Set to **Yes** to enable SMB Security on SMB shares.  Set access by user to allow access and whether or not the user can write to the share.
> + Set to **Hidden** to enable SMB Security on SMB shares that will not be visible.  Set access by user to allow access and whether or not the user can write to the share.
> + Set to **No** will share devices, SMB/NFS, and iso Mounts Public with read and write access.
:end

_(Add)_ 'force user = nobody' _(to SMB share config)_?
: <select name="force_user" size="1">
  <?=mk_option($cfg["Config"]["force_user"], "yes", "_(Yes)_");?>
  <?=mk_option($cfg["Config"]["force_user"], "no", "_(No)_");?>
  </select>

:ud_settings_force_user_plug:
> There are times when permissions on SMB shares aren't handled as expected.  Turning this feature on can help with those permissions.
> This applies to all devices mounted with Unassigned Devices.
> The down side is that it overrides Linux group permissions.  If you are unsure about whether or not this is necessary, leave it enabled.
:end

&nbsp;
: <input type="submit" name="#apply" value='_(Apply)_'><input type="button" value='_(Done)_' onclick="done()">
</form>

<div id="title" class="nocontrol">_(NFS Settings)_</div>
<form markdown="1" name="nfs_settings" method="POST">
_(Enable NFS export)_?
: <select name="nfs_export" size="1" <?if ($var['shareNFSEnabled']=="no"):?>disabled<?endif;?>>
  <?=mk_option($cfg['Config']["nfs_export"], "no", "_(No)_");?>
  <?=mk_option($cfg['Config']["nfs_export"], "yes", "_(Yes)_");?>
  </select><?if ($var['shareNFSEnabled']=="no"):?>&nbsp;_(NFS must be enabled to enable NFS Export)_.<?endif;?>

<div id="nfs_security" style="display: <?=($cfg['Config']["nfs_export"] == "no" ? "none" : "block");?>">
<dl>
	<dt>_(NFS Security)_:</dt>
	<dd>
		<select name="nfs_security" size="1">
		<?=mk_option($cfg["Config"]["nfs_security"], "public", "_(Public)_");?>
		<?=mk_option($cfg["Config"]["nfs_security"], "private", "_(Private)_");?>
		</select>
	</dd>
</dl>

<div id="nfs_rule" style="display: <?=($cfg['Config']["nfs_security"] == "public" ? "none" : "block");?>">
	<dl>
		<dt>_(Rule)_:</dt>
		<dd>
			<input type="text" name="nfs_rule" class="wide" maxlength="100" value="<?=$cfg['Config']["nfs_rule"];?>">
		</dd>
	</dl>
	</div>
</div>

:ud_settings_nfs_shares_plug:
> Set to **Yes** to export NFS shares.  Shares are exported Public with read and write access or Private with the rule you set.  Access is controlled with permission settings on files and folders.
:end

&nbsp;
: <input type="submit" name="#apply" value='_(Apply)_'><input type="button" value='_(Done)_' onclick="done()">
</form>

<div id="title" class="nocontrol">_(Set Encrypted Disk Password)_</div>
<form markdown="1" name="set_pass" method="POST">
_(Select Disk)_:
: <select name="set_pass" size="1">

  <?foreach ($encrypt_devices as $d) {?>
  <?=mk_option($disk_encrypt, ($d['label']), ($d['label']))?>
  <?}?>
  </select>

_(Enter Disk Password)_:

: <input type="password" name="password" class="wide" maxlength="100" value="">
  
:ud_settings_disk_pass_plug:
> Select the disk that you want to set a Password.  This is the password for this disk only and does not affect the array password/passphrase.  Leave password blank to use the array password/passphrase.
:end

&nbsp;
: <form name="change_disk_pass" method="POST" action="/update.php" target="progressFrame">
   	<input type="hidden" name="#command" value="chg_pass">
    <input type="submit" value='_(Set Password)_' title='_(Set the disk Password)_.' <?=count($encrypt_devices) ? "" : "disabled";?>>
  </form>
</form>

<div id="title" class="nocontrol">_(Change Disk UUID)_</div>
<form markdown="1" name="change_uuid" method="POST">
_(Select Disk to change UUID)_:
: <select name="change_uuid" size="1">

  <?foreach ($uuid_devices as $d) {?>
  <?=mk_option($disk_uuid, ("(".$d['device'].") - ".$d['label']), ("(".$d['device'].") - ".$d['label']));?>
  <?}?>
  </select>
  
:ud_settings_change_uuid_plug:
> Select the disk that you want to change the UUID.  This is useful when a disk has been removed from the array and has the same UUID as an array disk.  Drive must be unmounted to change the UUID.
:end

&nbsp;
: <form name="change_disk_uuid" method="POST" action="/update.php" target="progressFrame">
   	<input type="hidden" name="#command" value="UUID">
    <input type="submit" value='_(Change UUID)_' title='_(Change the disk UUID)_.' <?=count($uuid_devices) ? "" : "disabled";?>>
  </form>
</form>
<?endif;?>
